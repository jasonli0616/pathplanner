<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PathPlannerLib: pathplanner::PathPlanner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PathPlannerLib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classpathplanner_1_1PathPlanner.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classpathplanner_1_1PathPlanner-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pathplanner::PathPlanner Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5c5ac0334bdb5b0dca499743b2a19245"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a5c5ac0334bdb5b0dca499743b2a19245">loadPath</a> (std::string const &amp;name, <a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const constraints, bool const reversed=false)</td></tr>
<tr class="memdesc:a5c5ac0334bdb5b0dca499743b2a19245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a path file from storage.  <a href="classpathplanner_1_1PathPlanner.html#a5c5ac0334bdb5b0dca499743b2a19245">More...</a><br /></td></tr>
<tr class="separator:a5c5ac0334bdb5b0dca499743b2a19245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89228dee663c586c736129653012f175"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a89228dee663c586c736129653012f175">loadPath</a> (std::string const &amp;name, units::meters_per_second_t const maxVel, units::meters_per_second_squared_t const maxAccel, bool const reversed=false)</td></tr>
<tr class="memdesc:a89228dee663c586c736129653012f175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a path file from storage.  <a href="classpathplanner_1_1PathPlanner.html#a89228dee663c586c736129653012f175">More...</a><br /></td></tr>
<tr class="separator:a89228dee663c586c736129653012f175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a73b9720278945cdae4798a90b0af3d"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a9a73b9720278945cdae4798a90b0af3d">loadPathGroup</a> (std::string const &amp;name, std::initializer_list&lt; <a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> &gt; const constraints, bool const reversed=false)</td></tr>
<tr class="memdesc:a9a73b9720278945cdae4798a90b0af3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a path file from storage as a path group. This will separate the path into multiple paths based on the waypoints marked as "stop points".  <a href="classpathplanner_1_1PathPlanner.html#a9a73b9720278945cdae4798a90b0af3d">More...</a><br /></td></tr>
<tr class="separator:a9a73b9720278945cdae4798a90b0af3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebddffe1db12992636f6228130c6392"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a3ebddffe1db12992636f6228130c6392">loadPathGroup</a> (std::string const &amp;name, std::vector&lt; <a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> &gt; const constraints, bool const reversed=false)</td></tr>
<tr class="memdesc:a3ebddffe1db12992636f6228130c6392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a path file from storage as a path group. This will separate the path into multiple paths based on the waypoints marked as "stop points".  <a href="classpathplanner_1_1PathPlanner.html#a3ebddffe1db12992636f6228130c6392">More...</a><br /></td></tr>
<tr class="separator:a3ebddffe1db12992636f6228130c6392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81388de3657f0f2507e27ad85df8b2d4"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a81388de3657f0f2507e27ad85df8b2d4">loadPathGroup</a> (std::string const &amp;name, units::meters_per_second_t const maxVel, units::meters_per_second_squared_t const maxAccel, bool const reversed=false)</td></tr>
<tr class="memdesc:a81388de3657f0f2507e27ad85df8b2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a path file from storage as a path group. This will separate the path into multiple paths based on the waypoints marked as "stop points".  <a href="classpathplanner_1_1PathPlanner.html#a81388de3657f0f2507e27ad85df8b2d4">More...</a><br /></td></tr>
<tr class="separator:a81388de3657f0f2507e27ad85df8b2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb4b5e7ee7664903377717a2d6b968e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a4cb4b5e7ee7664903377717a2d6b968e">generatePath</a> (<a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const constraints, bool const reversed, std::vector&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const points, std::vector&lt; <a class="el" href="classpathplanner_1_1PathPlannerTrajectory_1_1EventMarker.html">PathPlannerTrajectory::EventMarker</a> &gt; const eventMarkers)</td></tr>
<tr class="memdesc:a4cb4b5e7ee7664903377717a2d6b968e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths.  <a href="classpathplanner_1_1PathPlanner.html#a4cb4b5e7ee7664903377717a2d6b968e">More...</a><br /></td></tr>
<tr class="separator:a4cb4b5e7ee7664903377717a2d6b968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cbc07c840446c27bc239b58e8cfbfd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a30cbc07c840446c27bc239b58e8cfbfd">generatePath</a> (<a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const constraints, bool const reversed, std::vector&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const points)</td></tr>
<tr class="memdesc:a30cbc07c840446c27bc239b58e8cfbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths.  <a href="classpathplanner_1_1PathPlanner.html#a30cbc07c840446c27bc239b58e8cfbfd">More...</a><br /></td></tr>
<tr class="separator:a30cbc07c840446c27bc239b58e8cfbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5534b1fae1a5295c4f89ab65c99d34"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a6e5534b1fae1a5295c4f89ab65c99d34">generatePath</a> (units::meters_per_second_t const maxVel, units::meters_per_second_squared_t const maxAccel, bool const reversed, std::vector&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const points)</td></tr>
<tr class="memdesc:a6e5534b1fae1a5295c4f89ab65c99d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths.  <a href="classpathplanner_1_1PathPlanner.html#a6e5534b1fae1a5295c4f89ab65c99d34">More...</a><br /></td></tr>
<tr class="separator:a6e5534b1fae1a5295c4f89ab65c99d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967692afff6946783e270dc0f6858b19"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a967692afff6946783e270dc0f6858b19">generatePath</a> (<a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const constraints, std::vector&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const points)</td></tr>
<tr class="memdesc:a967692afff6946783e270dc0f6858b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths.  <a href="classpathplanner_1_1PathPlanner.html#a967692afff6946783e270dc0f6858b19">More...</a><br /></td></tr>
<tr class="separator:a967692afff6946783e270dc0f6858b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3420958bb890e41718ee2a47355140"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a7b3420958bb890e41718ee2a47355140">generatePath</a> (units::meters_per_second_t const maxVel, units::meters_per_second_squared_t const maxAccel, std::vector&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const points)</td></tr>
<tr class="memdesc:a7b3420958bb890e41718ee2a47355140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths.  <a href="classpathplanner_1_1PathPlanner.html#a7b3420958bb890e41718ee2a47355140">More...</a><br /></td></tr>
<tr class="separator:a7b3420958bb890e41718ee2a47355140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ffa11d2d8444541fd1416395dfb80b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#ac8ffa11d2d8444541fd1416395dfb80b">generatePath</a> (<a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const constraints, bool const reversed, <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const point1, <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const point2, std::initializer_list&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const points={ })</td></tr>
<tr class="memdesc:ac8ffa11d2d8444541fd1416395dfb80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths.  <a href="classpathplanner_1_1PathPlanner.html#ac8ffa11d2d8444541fd1416395dfb80b">More...</a><br /></td></tr>
<tr class="separator:ac8ffa11d2d8444541fd1416395dfb80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74907aa538a87ef1371b4faabb23858"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#aa74907aa538a87ef1371b4faabb23858">generatePath</a> (units::meters_per_second_t const maxVel, units::meters_per_second_squared_t const maxAccel, bool const reversed, <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const point1, <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const point2, std::initializer_list&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const points={ })</td></tr>
<tr class="memdesc:aa74907aa538a87ef1371b4faabb23858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths.  <a href="classpathplanner_1_1PathPlanner.html#aa74907aa538a87ef1371b4faabb23858">More...</a><br /></td></tr>
<tr class="separator:aa74907aa538a87ef1371b4faabb23858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671d0da8706c52ab95c7b4086528aa76"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a671d0da8706c52ab95c7b4086528aa76">generatePath</a> (<a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const constraints, <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const point1, <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const point2, std::initializer_list&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const points={ })</td></tr>
<tr class="memdesc:a671d0da8706c52ab95c7b4086528aa76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths.  <a href="classpathplanner_1_1PathPlanner.html#a671d0da8706c52ab95c7b4086528aa76">More...</a><br /></td></tr>
<tr class="separator:a671d0da8706c52ab95c7b4086528aa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b934832dc059ddbb78234852b69c84"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#ac3b934832dc059ddbb78234852b69c84">generatePath</a> (units::meters_per_second_t const maxVel, units::meters_per_second_squared_t const maxAccel, <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const point1, <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const point2, std::initializer_list&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const points={ })</td></tr>
<tr class="memdesc:ac3b934832dc059ddbb78234852b69c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths.  <a href="classpathplanner_1_1PathPlanner.html#ac3b934832dc059ddbb78234852b69c84">More...</a><br /></td></tr>
<tr class="separator:ac3b934832dc059ddbb78234852b69c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ff112941bcf43fd6a529d4c6e4ba64"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpathplanner_1_1PathPlanner.html#a77ff112941bcf43fd6a529d4c6e4ba64">getConstraintsFromPath</a> (std::string const &amp;name)</td></tr>
<tr class="separator:a77ff112941bcf43fd6a529d4c6e4ba64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:abba0897379a9358a401287555b9eb0fc"><td class="memItemLeft" align="right" valign="top"><a id="abba0897379a9358a401287555b9eb0fc" name="abba0897379a9358a401287555b9eb0fc"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>resolution</b> = 0.004</td></tr>
<tr class="separator:abba0897379a9358a401287555b9eb0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac8ffa11d2d8444541fd1416395dfb80b" name="ac8ffa11d2d8444541fd1416395dfb80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ffa11d2d8444541fd1416395dfb80b">&#9670;&#160;</a></span>generatePath() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> PathPlanner::generatePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const&#160;</td>
          <td class="paramname"><em>point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const&#160;</td>
          <td class="paramname"><em>points</em> = <code>{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraints</td><td>The max velocity and max acceleration of the path </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow this path reversed </td></tr>
    <tr><td class="paramname">point1</td><td>First point in the path </td></tr>
    <tr><td class="paramname">point2</td><td>Second point in the path </td></tr>
    <tr><td class="paramname">points</td><td>Remaining points in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="a30cbc07c840446c27bc239b58e8cfbfd" name="a30cbc07c840446c27bc239b58e8cfbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cbc07c840446c27bc239b58e8cfbfd">&#9670;&#160;</a></span>generatePath() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> pathplanner::PathPlanner::generatePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraints</td><td>The max velocity and max acceleration of the path </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow this path reversed </td></tr>
    <tr><td class="paramname">points</td><td>Points in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="a4cb4b5e7ee7664903377717a2d6b968e" name="a4cb4b5e7ee7664903377717a2d6b968e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb4b5e7ee7664903377717a2d6b968e">&#9670;&#160;</a></span>generatePath() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> PathPlanner::generatePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classpathplanner_1_1PathPlannerTrajectory_1_1EventMarker.html">PathPlannerTrajectory::EventMarker</a> &gt; const&#160;</td>
          <td class="paramname"><em>eventMarkers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraints</td><td>The max velocity and max acceleration of the path </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow this path reversed </td></tr>
    <tr><td class="paramname">points</td><td>Points in the path </td></tr>
    <tr><td class="paramname">eventMarkers</td><td>Markers in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="a671d0da8706c52ab95c7b4086528aa76" name="a671d0da8706c52ab95c7b4086528aa76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671d0da8706c52ab95c7b4086528aa76">&#9670;&#160;</a></span>generatePath() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> pathplanner::PathPlanner::generatePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const&#160;</td>
          <td class="paramname"><em>point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const&#160;</td>
          <td class="paramname"><em>points</em> = <code>{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraints</td><td>The max velocity and max acceleration of the path </td></tr>
    <tr><td class="paramname">point1</td><td>First point in the path </td></tr>
    <tr><td class="paramname">point2</td><td>Second point in the path </td></tr>
    <tr><td class="paramname">points</td><td>Remaining points in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="a967692afff6946783e270dc0f6858b19" name="a967692afff6946783e270dc0f6858b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967692afff6946783e270dc0f6858b19">&#9670;&#160;</a></span>generatePath() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> pathplanner::PathPlanner::generatePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraints</td><td>The max velocity and max acceleration of the path </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow this path reversed </td></tr>
    <tr><td class="paramname">points</td><td>Points in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="aa74907aa538a87ef1371b4faabb23858" name="aa74907aa538a87ef1371b4faabb23858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74907aa538a87ef1371b4faabb23858">&#9670;&#160;</a></span>generatePath() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> pathplanner::PathPlanner::generatePath </td>
          <td>(</td>
          <td class="paramtype">units::meters_per_second_t const&#160;</td>
          <td class="paramname"><em>maxVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_squared_t const&#160;</td>
          <td class="paramname"><em>maxAccel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const&#160;</td>
          <td class="paramname"><em>point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const&#160;</td>
          <td class="paramname"><em>points</em> = <code>{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxVel</td><td>The max velocity of the path </td></tr>
    <tr><td class="paramname">maxAccel</td><td>The max acceleration of the path </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow this path reversed </td></tr>
    <tr><td class="paramname">point1</td><td>First point in the path </td></tr>
    <tr><td class="paramname">point2</td><td>Second point in the path </td></tr>
    <tr><td class="paramname">points</td><td>Remaining points in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="a6e5534b1fae1a5295c4f89ab65c99d34" name="a6e5534b1fae1a5295c4f89ab65c99d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5534b1fae1a5295c4f89ab65c99d34">&#9670;&#160;</a></span>generatePath() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> pathplanner::PathPlanner::generatePath </td>
          <td>(</td>
          <td class="paramtype">units::meters_per_second_t const&#160;</td>
          <td class="paramname"><em>maxVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_squared_t const&#160;</td>
          <td class="paramname"><em>maxAccel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxVel</td><td>The max velocity of the path </td></tr>
    <tr><td class="paramname">maxAccel</td><td>The max acceleration of the path </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow this path reversed </td></tr>
    <tr><td class="paramname">points</td><td>Points in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="ac3b934832dc059ddbb78234852b69c84" name="ac3b934832dc059ddbb78234852b69c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b934832dc059ddbb78234852b69c84">&#9670;&#160;</a></span>generatePath() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> pathplanner::PathPlanner::generatePath </td>
          <td>(</td>
          <td class="paramtype">units::meters_per_second_t const&#160;</td>
          <td class="paramname"><em>maxVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_squared_t const&#160;</td>
          <td class="paramname"><em>maxAccel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> const&#160;</td>
          <td class="paramname"><em>point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const&#160;</td>
          <td class="paramname"><em>points</em> = <code>{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxVel</td><td>The max velocity of the path </td></tr>
    <tr><td class="paramname">maxAccel</td><td>The max acceleration of the path </td></tr>
    <tr><td class="paramname">point1</td><td>First point in the path </td></tr>
    <tr><td class="paramname">point2</td><td>Second point in the path </td></tr>
    <tr><td class="paramname">points</td><td>Remaining points in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="a7b3420958bb890e41718ee2a47355140" name="a7b3420958bb890e41718ee2a47355140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3420958bb890e41718ee2a47355140">&#9670;&#160;</a></span>generatePath() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> pathplanner::PathPlanner::generatePath </td>
          <td>(</td>
          <td class="paramtype">units::meters_per_second_t const&#160;</td>
          <td class="paramname"><em>maxVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_squared_t const&#160;</td>
          <td class="paramname"><em>maxAccel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classpathplanner_1_1PathPoint.html">PathPoint</a> &gt; const&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a path on-the-fly from a list of points As you can't see the path in the GUI when using this method, make sure you have a good idea of what works well and what doesn't before you use this method in competition. Points positioned in weird configurations such as being too close together can lead to really janky paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxVel</td><td>The max velocity of the path </td></tr>
    <tr><td class="paramname">maxAccel</td><td>The max acceleration of the path </td></tr>
    <tr><td class="paramname">points</td><td>Points in the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="a77ff112941bcf43fd6a529d4c6e4ba64" name="a77ff112941bcf43fd6a529d4c6e4ba64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ff112941bcf43fd6a529d4c6e4ba64">&#9670;&#160;</a></span>getConstraintsFromPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> PathPlanner::getConstraintsFromPath </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Load path constraints from a path file in storage. This can be used to change path max vel/accel in the GUI instead of updating and rebuilding code. This requires that max velocity and max acceleration have been explicitly set in the GUI.</p>
<p >Throws a runtime error if constraints are not present in the file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the path to load constraints from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constraints from the path file </dd></dl>

</div>
</div>
<a id="a5c5ac0334bdb5b0dca499743b2a19245" name="a5c5ac0334bdb5b0dca499743b2a19245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5ac0334bdb5b0dca499743b2a19245">&#9670;&#160;</a></span>loadPath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> PathPlanner::loadPath </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> const&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>reversed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a path file from storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the path to load </td></tr>
    <tr><td class="paramname">constraints</td><td>The max velocity and acceleration of the path </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow the path reversed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="a89228dee663c586c736129653012f175" name="a89228dee663c586c736129653012f175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89228dee663c586c736129653012f175">&#9670;&#160;</a></span>loadPath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> pathplanner::PathPlanner::loadPath </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_t const&#160;</td>
          <td class="paramname"><em>maxVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_squared_t const&#160;</td>
          <td class="paramname"><em>maxAccel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>reversed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a path file from storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the path to load </td></tr>
    <tr><td class="paramname">maxVel</td><td>Max velocity of the path </td></tr>
    <tr><td class="paramname">maxAccel</td><td>Max acceleration of the path </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow the path reversed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated path </dd></dl>

</div>
</div>
<a id="a9a73b9720278945cdae4798a90b0af3d" name="a9a73b9720278945cdae4798a90b0af3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a73b9720278945cdae4798a90b0af3d">&#9670;&#160;</a></span>loadPathGroup() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> &gt; PathPlanner::loadPathGroup </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> &gt; const&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>reversed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a path file from storage as a path group. This will separate the path into multiple paths based on the waypoints marked as "stop points". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the path group to load </td></tr>
    <tr><td class="paramname">constraints</td><td>Initializer list of path constraints for each path in the group. This requires at least one path constraint. If less constraints than paths are provided, the last constraint will be used for the rest of the paths. </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow the path group reversed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of all generated paths in the group </dd></dl>

</div>
</div>
<a id="a3ebddffe1db12992636f6228130c6392" name="a3ebddffe1db12992636f6228130c6392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebddffe1db12992636f6228130c6392">&#9670;&#160;</a></span>loadPathGroup() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> &gt; PathPlanner::loadPathGroup </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classpathplanner_1_1PathConstraints.html">PathConstraints</a> &gt; const&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>reversed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a path file from storage as a path group. This will separate the path into multiple paths based on the waypoints marked as "stop points". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the path group to load </td></tr>
    <tr><td class="paramname">constraints</td><td>Vector of path constraints for each path in the group. This requires at least one path constraint. If less constraints than paths are provided, the last constraint will be used for the rest of the paths. </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow the path group reversed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of all generated paths in the group </dd></dl>

</div>
</div>
<a id="a81388de3657f0f2507e27ad85df8b2d4" name="a81388de3657f0f2507e27ad85df8b2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81388de3657f0f2507e27ad85df8b2d4">&#9670;&#160;</a></span>loadPathGroup() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="classpathplanner_1_1PathPlannerTrajectory.html">PathPlannerTrajectory</a> &gt; pathplanner::PathPlanner::loadPathGroup </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_t const&#160;</td>
          <td class="paramname"><em>maxVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_squared_t const&#160;</td>
          <td class="paramname"><em>maxAccel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>reversed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a path file from storage as a path group. This will separate the path into multiple paths based on the waypoints marked as "stop points". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the path group to load </td></tr>
    <tr><td class="paramname">maxVel</td><td>Max velocity of every path in the group </td></tr>
    <tr><td class="paramname">maxAccel</td><td>Max acceleration of every path in the group </td></tr>
    <tr><td class="paramname">reversed</td><td>Should the robot follow the path group reversed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of all generated paths in the group </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/main/native/include/pathplanner/lib/<a class="el" href="PathPlanner_8h_source.html">PathPlanner.h</a></li>
<li>src/main/native/cpp/pathplanner/lib/PathPlanner.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>pathplanner</b></li><li class="navelem"><a class="el" href="classpathplanner_1_1PathPlanner.html">PathPlanner</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
